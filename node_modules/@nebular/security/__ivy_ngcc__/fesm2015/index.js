import { Directive, Inject, Injectable, InjectionToken, Input, NgModule, Optional, TemplateRef, ViewContainerRef } from '@angular/core';
import { __decorate, __metadata, __param } from 'tslib';
import { CommonModule } from '@angular/common';
import { map, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';

import * as ɵngcc0 from '@angular/core';
const NB_SECURITY_OPTIONS_TOKEN = new InjectionToken('Nebular Security Options');

var NbAclService_1;
/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const shallowObjectClone = (o) => Object.assign({}, o);
const ɵ0 = shallowObjectClone;
const shallowArrayClone = (a) => Object.assign([], a);
const ɵ1 = shallowArrayClone;
const popParent = (abilities) => {
    const parent = abilities['parent'];
    delete abilities['parent'];
    return parent;
};
const ɵ2 = popParent;
/**
 * Common acl service.
 */
let NbAclService = NbAclService_1 = class NbAclService {
    constructor(settings = {}) {
        this.settings = settings;
        this.state = {};
        if (settings.accessControl) {
            this.setAccessControl(settings.accessControl);
        }
    }
    /**
     * Set/Reset ACL list
     * @param {NbAccessControl} list
     */
    setAccessControl(list) {
        for (const [role, value] of Object.entries(list)) {
            const abilities = shallowObjectClone(value);
            const parent = popParent(abilities);
            this.register(role, parent, abilities);
        }
    }
    /**
     * Register a new role with a list of abilities (permission/resources combinations)
     * @param {string} role
     * @param {string} parent
     * @param {[permission: string]: string|string[]} abilities
     */
    register(role, parent = null, abilities = {}) {
        this.validateRole(role);
        this.state[role] = {
            parent: parent,
        };
        for (const [permission, value] of Object.entries(abilities)) {
            const resources = typeof value === 'string' ? [value] : value;
            this.allow(role, permission, shallowArrayClone(resources));
        }
    }
    /**
     * Allow a permission for specific resources to a role
     * @param {string} role
     * @param {string} permission
     * @param {string | string[]} resource
     */
    allow(role, permission, resource) {
        this.validateRole(role);
        if (!this.getRole(role)) {
            this.register(role, null, {});
        }
        resource = typeof resource === 'string' ? [resource] : resource;
        let resources = shallowArrayClone(this.getRoleResources(role, permission));
        resources = resources.concat(resource);
        this.state[role][permission] = resources
            .filter((item, pos) => resources.indexOf(item) === pos);
    }
    /**
     * Check whether the role has a permission to a resource
     * @param {string} role
     * @param {string} permission
     * @param {string} resource
     * @returns {boolean}
     */
    can(role, permission, resource) {
        this.validateResource(resource);
        const parentRole = this.getRoleParent(role);
        const parentCan = parentRole && this.can(this.getRoleParent(role), permission, resource);
        return parentCan || this.exactCan(role, permission, resource);
    }
    getRole(role) {
        return this.state[role];
    }
    validateRole(role) {
        if (!role) {
            throw new Error('NbAclService: role name cannot be empty');
        }
    }
    validateResource(resource) {
        if (!resource || [NbAclService_1.ANY_RESOURCE].includes(resource)) {
            throw new Error(`NbAclService: cannot use empty or bulk '*' resource placeholder with 'can' method`);
        }
    }
    exactCan(role, permission, resource) {
        const resources = this.getRoleResources(role, permission);
        return resources.includes(resource) || resources.includes(NbAclService_1.ANY_RESOURCE);
    }
    getRoleResources(role, permission) {
        return this.getRoleAbilities(role)[permission] || [];
    }
    getRoleAbilities(role) {
        const abilities = shallowObjectClone(this.state[role] || {});
        popParent(shallowObjectClone(this.state[role] || {}));
        return abilities;
    }
    getRoleParent(role) {
        return this.state[role] ? this.state[role]['parent'] : null;
    }
};
NbAclService.ɵfac = function NbAclService_Factory(t) { return new (t || NbAclService)(ɵngcc0.ɵɵinject(NB_SECURITY_OPTIONS_TOKEN, 8)); };
NbAclService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbAclService, factory: NbAclService.ɵfac });
NbAclService.ANY_RESOURCE = '*';
NbAclService = NbAclService_1 = __decorate([ __param(0, Optional()), __param(0, Inject(NB_SECURITY_OPTIONS_TOKEN)),
    __metadata("design:paramtypes", [Object])
], NbAclService);

class NbRoleProvider {
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Access checker service.
 *
 * Injects `NbRoleProvider` to determine current user role, and checks access permissions using `NbAclService`
 */
let NbAccessChecker = class NbAccessChecker {
    constructor(roleProvider, acl) {
        this.roleProvider = roleProvider;
        this.acl = acl;
    }
    /**
     * Checks whether access is granted or not
     *
     * @param {string} permission
     * @param {string} resource
     * @returns {Observable<boolean>}
     */
    isGranted(permission, resource) {
        return this.roleProvider.getRole()
            .pipe(map((role) => Array.isArray(role) ? role : [role]), map((roles) => {
            return roles.some(role => this.acl.can(role, permission, resource));
        }));
    }
};
NbAccessChecker.ɵfac = function NbAccessChecker_Factory(t) { return new (t || NbAccessChecker)(ɵngcc0.ɵɵinject(NbRoleProvider), ɵngcc0.ɵɵinject(NbAclService)); };
NbAccessChecker.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbAccessChecker, factory: NbAccessChecker.ɵfac });
NbAccessChecker = __decorate([ __metadata("design:paramtypes", [NbRoleProvider, NbAclService])
], NbAccessChecker);

let NbIsGrantedDirective = class NbIsGrantedDirective {
    constructor(templateRef, viewContainer, accessChecker) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.accessChecker = accessChecker;
        this.destroy$ = new Subject();
        this.hasView = false;
    }
    set nbIsGranted([permission, resource]) {
        this.accessChecker.isGranted(permission, resource)
            .pipe(takeUntil(this.destroy$))
            .subscribe((can) => {
            if (can && !this.hasView) {
                this.viewContainer.createEmbeddedView(this.templateRef);
                this.hasView = true;
            }
            else if (!can && this.hasView) {
                this.viewContainer.clear();
                this.hasView = false;
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
};
NbIsGrantedDirective.ɵfac = function NbIsGrantedDirective_Factory(t) { return new (t || NbIsGrantedDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(NbAccessChecker)); };
NbIsGrantedDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbIsGrantedDirective, selectors: [["", "nbIsGranted", ""]], inputs: { nbIsGranted: "nbIsGranted" } });
__decorate([
    Input(),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], NbIsGrantedDirective.prototype, "nbIsGranted", null);
NbIsGrantedDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef,
        ViewContainerRef,
        NbAccessChecker])
], NbIsGrantedDirective);

var NbSecurityModule_1;
let NbSecurityModule = NbSecurityModule_1 = class NbSecurityModule {
    static forRoot(nbSecurityOptions) {
        return {
            ngModule: NbSecurityModule_1,
            providers: [
                { provide: NB_SECURITY_OPTIONS_TOKEN, useValue: nbSecurityOptions },
                NbAclService,
                NbAccessChecker,
            ],
        };
    }
};
NbSecurityModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSecurityModule });
NbSecurityModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbSecurityModule_Factory(t) { return new (t || NbSecurityModule)(); }, imports: [[
            CommonModule,
        ]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAclService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_SECURITY_OPTIONS_TOKEN]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAccessChecker, [{
        type: Injectable
    }], function () { return [{ type: NbRoleProvider }, { type: NbAclService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbIsGrantedDirective, [{
        type: Directive,
        args: [{ selector: '[nbIsGranted]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: NbAccessChecker }]; }, { nbIsGranted: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSecurityModule, { declarations: function () { return [NbIsGrantedDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NbIsGrantedDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSecurityModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    NbIsGrantedDirective,
                ],
                exports: [
                    NbIsGrantedDirective,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NB_SECURITY_OPTIONS_TOKEN, NbSecurityModule, NbAclService, ɵ0, ɵ1, ɵ2, NbAccessChecker, NbRoleProvider, NbIsGrantedDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29HQWtIRTs7NENBRTBDLEFBRXpDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZHQW1DRDs4QkFDNEIsQUFFM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUtBNkJEOzs7Ozs7bUNBTWlDLEFBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFpQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5wdXQsIE5nTW9kdWxlLCBPcHRpb25hbCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgbWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IE5CX1NFQ1VSSVRZX09QVElPTlNfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05lYnVsYXIgU2VjdXJpdHkgT3B0aW9ucycpO1xuXG52YXIgTmJBY2xTZXJ2aWNlXzE7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBzaGFsbG93T2JqZWN0Q2xvbmUgPSAobykgPT4gT2JqZWN0LmFzc2lnbih7fSwgbyk7XG5jb25zdCDJtTAgPSBzaGFsbG93T2JqZWN0Q2xvbmU7XG5jb25zdCBzaGFsbG93QXJyYXlDbG9uZSA9IChhKSA9PiBPYmplY3QuYXNzaWduKFtdLCBhKTtcbmNvbnN0IMm1MSA9IHNoYWxsb3dBcnJheUNsb25lO1xuY29uc3QgcG9wUGFyZW50ID0gKGFiaWxpdGllcykgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGFiaWxpdGllc1sncGFyZW50J107XG4gICAgZGVsZXRlIGFiaWxpdGllc1sncGFyZW50J107XG4gICAgcmV0dXJuIHBhcmVudDtcbn07XG5jb25zdCDJtTIgPSBwb3BQYXJlbnQ7XG4vKipcbiAqIENvbW1vbiBhY2wgc2VydmljZS5cbiAqL1xubGV0IE5iQWNsU2VydmljZSA9IE5iQWNsU2VydmljZV8xID0gY2xhc3MgTmJBY2xTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWNjZXNzQ29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBY2Nlc3NDb250cm9sKHNldHRpbmdzLmFjY2Vzc0NvbnRyb2wpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldC9SZXNldCBBQ0wgbGlzdFxuICAgICAqIEBwYXJhbSB7TmJBY2Nlc3NDb250cm9sfSBsaXN0XG4gICAgICovXG4gICAgc2V0QWNjZXNzQ29udHJvbChsaXN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgW3JvbGUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhsaXN0KSkge1xuICAgICAgICAgICAgY29uc3QgYWJpbGl0aWVzID0gc2hhbGxvd09iamVjdENsb25lKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBvcFBhcmVudChhYmlsaXRpZXMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcihyb2xlLCBwYXJlbnQsIGFiaWxpdGllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBuZXcgcm9sZSB3aXRoIGEgbGlzdCBvZiBhYmlsaXRpZXMgKHBlcm1pc3Npb24vcmVzb3VyY2VzIGNvbWJpbmF0aW9ucylcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRcbiAgICAgKiBAcGFyYW0ge1twZXJtaXNzaW9uOiBzdHJpbmddOiBzdHJpbmd8c3RyaW5nW119IGFiaWxpdGllc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyKHJvbGUsIHBhcmVudCA9IG51bGwsIGFiaWxpdGllcyA9IHt9KSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVSb2xlKHJvbGUpO1xuICAgICAgICB0aGlzLnN0YXRlW3JvbGVdID0ge1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW3Blcm1pc3Npb24sIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhYmlsaXRpZXMpKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gW3ZhbHVlXSA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hbGxvdyhyb2xlLCBwZXJtaXNzaW9uLCBzaGFsbG93QXJyYXlDbG9uZShyZXNvdXJjZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvdyBhIHBlcm1pc3Npb24gZm9yIHNwZWNpZmljIHJlc291cmNlcyB0byBhIHJvbGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwZXJtaXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gcmVzb3VyY2VcbiAgICAgKi9cbiAgICBhbGxvdyhyb2xlLCBwZXJtaXNzaW9uLCByZXNvdXJjZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlUm9sZShyb2xlKTtcbiAgICAgICAgaWYgKCF0aGlzLmdldFJvbGUocm9sZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIocm9sZSwgbnVsbCwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJlc291cmNlID0gdHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJyA/IFtyZXNvdXJjZV0gOiByZXNvdXJjZTtcbiAgICAgICAgbGV0IHJlc291cmNlcyA9IHNoYWxsb3dBcnJheUNsb25lKHRoaXMuZ2V0Um9sZVJlc291cmNlcyhyb2xlLCBwZXJtaXNzaW9uKSk7XG4gICAgICAgIHJlc291cmNlcyA9IHJlc291cmNlcy5jb25jYXQocmVzb3VyY2UpO1xuICAgICAgICB0aGlzLnN0YXRlW3JvbGVdW3Blcm1pc3Npb25dID0gcmVzb3VyY2VzXG4gICAgICAgICAgICAuZmlsdGVyKChpdGVtLCBwb3MpID0+IHJlc291cmNlcy5pbmRleE9mKGl0ZW0pID09PSBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSByb2xlIGhhcyBhIHBlcm1pc3Npb24gdG8gYSByZXNvdXJjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb2xlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBlcm1pc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW4ocm9sZSwgcGVybWlzc2lvbiwgcmVzb3VyY2UpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlc291cmNlKHJlc291cmNlKTtcbiAgICAgICAgY29uc3QgcGFyZW50Um9sZSA9IHRoaXMuZ2V0Um9sZVBhcmVudChyb2xlKTtcbiAgICAgICAgY29uc3QgcGFyZW50Q2FuID0gcGFyZW50Um9sZSAmJiB0aGlzLmNhbih0aGlzLmdldFJvbGVQYXJlbnQocm9sZSksIHBlcm1pc3Npb24sIHJlc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudENhbiB8fCB0aGlzLmV4YWN0Q2FuKHJvbGUsIHBlcm1pc3Npb24sIHJlc291cmNlKTtcbiAgICB9XG4gICAgZ2V0Um9sZShyb2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlW3JvbGVdO1xuICAgIH1cbiAgICB2YWxpZGF0ZVJvbGUocm9sZSkge1xuICAgICAgICBpZiAoIXJvbGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmJBY2xTZXJ2aWNlOiByb2xlIG5hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVSZXNvdXJjZShyZXNvdXJjZSkge1xuICAgICAgICBpZiAoIXJlc291cmNlIHx8IFtOYkFjbFNlcnZpY2VfMS5BTllfUkVTT1VSQ0VdLmluY2x1ZGVzKHJlc291cmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYkFjbFNlcnZpY2U6IGNhbm5vdCB1c2UgZW1wdHkgb3IgYnVsayAnKicgcmVzb3VyY2UgcGxhY2Vob2xkZXIgd2l0aCAnY2FuJyBtZXRob2RgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGFjdENhbihyb2xlLCBwZXJtaXNzaW9uLCByZXNvdXJjZSkge1xuICAgICAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLmdldFJvbGVSZXNvdXJjZXMocm9sZSwgcGVybWlzc2lvbik7XG4gICAgICAgIHJldHVybiByZXNvdXJjZXMuaW5jbHVkZXMocmVzb3VyY2UpIHx8IHJlc291cmNlcy5pbmNsdWRlcyhOYkFjbFNlcnZpY2VfMS5BTllfUkVTT1VSQ0UpO1xuICAgIH1cbiAgICBnZXRSb2xlUmVzb3VyY2VzKHJvbGUsIHBlcm1pc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um9sZUFiaWxpdGllcyhyb2xlKVtwZXJtaXNzaW9uXSB8fCBbXTtcbiAgICB9XG4gICAgZ2V0Um9sZUFiaWxpdGllcyhyb2xlKSB7XG4gICAgICAgIGNvbnN0IGFiaWxpdGllcyA9IHNoYWxsb3dPYmplY3RDbG9uZSh0aGlzLnN0YXRlW3JvbGVdIHx8IHt9KTtcbiAgICAgICAgcG9wUGFyZW50KHNoYWxsb3dPYmplY3RDbG9uZSh0aGlzLnN0YXRlW3JvbGVdIHx8IHt9KSk7XG4gICAgICAgIHJldHVybiBhYmlsaXRpZXM7XG4gICAgfVxuICAgIGdldFJvbGVQYXJlbnQocm9sZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVtyb2xlXSA/IHRoaXMuc3RhdGVbcm9sZV1bJ3BhcmVudCddIDogbnVsbDtcbiAgICB9XG59O1xuTmJBY2xTZXJ2aWNlLkFOWV9SRVNPVVJDRSA9ICcqJztcbk5iQWNsU2VydmljZSA9IE5iQWNsU2VydmljZV8xID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMCwgSW5qZWN0KE5CX1NFQ1VSSVRZX09QVElPTlNfVE9LRU4pKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBOYkFjbFNlcnZpY2UpO1xuXG5jbGFzcyBOYlJvbGVQcm92aWRlciB7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQWNjZXNzIGNoZWNrZXIgc2VydmljZS5cbiAqXG4gKiBJbmplY3RzIGBOYlJvbGVQcm92aWRlcmAgdG8gZGV0ZXJtaW5lIGN1cnJlbnQgdXNlciByb2xlLCBhbmQgY2hlY2tzIGFjY2VzcyBwZXJtaXNzaW9ucyB1c2luZyBgTmJBY2xTZXJ2aWNlYFxuICovXG5sZXQgTmJBY2Nlc3NDaGVja2VyID0gY2xhc3MgTmJBY2Nlc3NDaGVja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihyb2xlUHJvdmlkZXIsIGFjbCkge1xuICAgICAgICB0aGlzLnJvbGVQcm92aWRlciA9IHJvbGVQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hY2wgPSBhY2w7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFjY2VzcyBpcyBncmFudGVkIG9yIG5vdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBlcm1pc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICBpc0dyYW50ZWQocGVybWlzc2lvbiwgcmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9sZVByb3ZpZGVyLmdldFJvbGUoKVxuICAgICAgICAgICAgLnBpcGUobWFwKChyb2xlKSA9PiBBcnJheS5pc0FycmF5KHJvbGUpID8gcm9sZSA6IFtyb2xlXSksIG1hcCgocm9sZXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByb2xlcy5zb21lKHJvbGUgPT4gdGhpcy5hY2wuY2FuKHJvbGUsIHBlcm1pc3Npb24sIHJlc291cmNlKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59O1xuTmJBY2Nlc3NDaGVja2VyID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJSb2xlUHJvdmlkZXIsIE5iQWNsU2VydmljZV0pXG5dLCBOYkFjY2Vzc0NoZWNrZXIpO1xuXG5sZXQgTmJJc0dyYW50ZWREaXJlY3RpdmUgPSBjbGFzcyBOYklzR3JhbnRlZERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXIsIGFjY2Vzc0NoZWNrZXIpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICAgICAgICB0aGlzLmFjY2Vzc0NoZWNrZXIgPSBhY2Nlc3NDaGVja2VyO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5oYXNWaWV3ID0gZmFsc2U7XG4gICAgfVxuICAgIHNldCBuYklzR3JhbnRlZChbcGVybWlzc2lvbiwgcmVzb3VyY2VdKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzQ2hlY2tlci5pc0dyYW50ZWQocGVybWlzc2lvbiwgcmVzb3VyY2UpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChjYW4pID0+IHtcbiAgICAgICAgICAgIGlmIChjYW4gJiYgIXRoaXMuaGFzVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNWaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjYW4gJiYgdGhpcy5oYXNWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNWaWV3ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgTmJJc0dyYW50ZWREaXJlY3RpdmUucHJvdG90eXBlLCBcIm5iSXNHcmFudGVkXCIsIG51bGwpO1xuTmJJc0dyYW50ZWREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tuYklzR3JhbnRlZF0nIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWYsXG4gICAgICAgIFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIE5iQWNjZXNzQ2hlY2tlcl0pXG5dLCBOYklzR3JhbnRlZERpcmVjdGl2ZSk7XG5cbnZhciBOYlNlY3VyaXR5TW9kdWxlXzE7XG5sZXQgTmJTZWN1cml0eU1vZHVsZSA9IE5iU2VjdXJpdHlNb2R1bGVfMSA9IGNsYXNzIE5iU2VjdXJpdHlNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KG5iU2VjdXJpdHlPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJTZWN1cml0eU1vZHVsZV8xLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9TRUNVUklUWV9PUFRJT05TX1RPS0VOLCB1c2VWYWx1ZTogbmJTZWN1cml0eU9wdGlvbnMgfSxcbiAgICAgICAgICAgICAgICBOYkFjbFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJBY2Nlc3NDaGVja2VyLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuTmJTZWN1cml0eU1vZHVsZSA9IE5iU2VjdXJpdHlNb2R1bGVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIE5iSXNHcmFudGVkRGlyZWN0aXZlLFxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICBOYklzR3JhbnRlZERpcmVjdGl2ZSxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJTZWN1cml0eU1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBOQl9TRUNVUklUWV9PUFRJT05TX1RPS0VOLCBOYlNlY3VyaXR5TW9kdWxlLCBOYkFjbFNlcnZpY2UsIMm1MCwgybUxLCDJtTIsIE5iQWNjZXNzQ2hlY2tlciwgTmJSb2xlUHJvdmlkZXIsIE5iSXNHcmFudGVkRGlyZWN0aXZlIH07XG4iXX0=