import { ElementRef, EventEmitter, OnDestroy, AfterViewInit, QueryList } from '@angular/core';
import { NbBooleanInput } from '../helpers';
import { NbLayoutScrollService } from '../../services/scroll.service';
import { NbLayoutRulerService } from '../../services/ruler.service';
import { NbListItemComponent } from './list.component';
import * as ɵngcc0 from '@angular/core';
export declare class NbScrollableContainerDimentions {
    scrollTop: number;
    scrollHeight: number;
    clientHeight: number;
}
/**
 * Infinite List Directive
 *
 * ```html
 *  <nb-list nbInfiniteList [threshold]="500" (bottomThreshold)="loadNext()">
 *    <nb-list-item *ngFor="let item of items"></nb-list-item>
 *  </nb-list>
 * ```
 *
 * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)
 *
 * Directive will notify when list scrolled up or down to a given threshold.
 * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.
 *
 * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)
 *
 * To improve UX of infinite lists, it's better to keep current page in url,
 * so user able to return to the last viewed page or to share a link to this page.
 * `nbListPageTracker` directive will help you to know, what page user currently viewing.
 * Just put it on a list, set page size and it will calculate page that currently in viewport.
 * You can [open the example](example/infinite-list/infinite-news-list.component)
 * in a new tab to check out this feature.
 *
 * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)
 *
 * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)
 *
 */
export declare class NbInfiniteListDirective implements AfterViewInit, OnDestroy {
    private elementRef;
    private scrollService;
    private dimensionsService;
    private destroy$;
    private lastScrollPosition;
    windowScroll: boolean;
    private get elementScroll();
    /**
     * Threshold after which event load more event will be emited.
     * In pixels.
     */
    threshold: number;
    /**
     * By default component observes list scroll position.
     * If set to `true`, component will observe position of page scroll instead.
     */
    set listenWindowScroll(value: any);
    static ngAcceptInputType_listenWindowScroll: NbBooleanInput;
    /**
     * Emits when distance between list bottom and current scroll position is less than threshold.
     */
    bottomThreshold: EventEmitter<any>;
    /**
     * Emits when distance between list top and current scroll position is less than threshold.
     */
    topThreshold: EventEmitter<any>;
    onElementScroll(): void;
    listItems: QueryList<NbListItemComponent>;
    constructor(elementRef: ElementRef, scrollService: NbLayoutScrollService, dimensionsService: NbLayoutRulerService);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    checkPosition({ scrollHeight, scrollTop, clientHeight }: NbScrollableContainerDimentions): void;
    private getContainerDimensions;
    private inSyncWithDom;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbInfiniteListDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbInfiniteListDirective, "[nbInfiniteList]", never, { "listenWindowScroll": "listenWindowScroll"; "threshold": "threshold"; }, { "bottomThreshold": "bottomThreshold"; "topThreshold": "topThreshold"; }, ["listItems"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5maW5pdGUtbGlzdC5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiaW5maW5pdGUtbGlzdC5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvRUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYkJvb2xlYW5JbnB1dCB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgTmJMYXlvdXRTY3JvbGxTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvc2Nyb2xsLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmJMYXlvdXRSdWxlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9ydWxlci5zZXJ2aWNlJztcbmltcG9ydCB7IE5iTGlzdEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2xpc3QuY29tcG9uZW50JztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iU2Nyb2xsYWJsZUNvbnRhaW5lckRpbWVudGlvbnMge1xuICAgIHNjcm9sbFRvcDogbnVtYmVyO1xuICAgIHNjcm9sbEhlaWdodDogbnVtYmVyO1xuICAgIGNsaWVudEhlaWdodDogbnVtYmVyO1xufVxuLyoqXG4gKiBJbmZpbml0ZSBMaXN0IERpcmVjdGl2ZVxuICpcbiAqIGBgYGh0bWxcbiAqICA8bmItbGlzdCBuYkluZmluaXRlTGlzdCBbdGhyZXNob2xkXT1cIjUwMFwiIChib3R0b21UaHJlc2hvbGQpPVwibG9hZE5leHQoKVwiPlxuICogICAgPG5iLWxpc3QtaXRlbSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPjwvbmItbGlzdC1pdGVtPlxuICogIDwvbmItbGlzdD5cbiAqIGBgYFxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2ltcGxlIGluZmluaXRlIGxpc3QsIGluZmluaXRlLWxpc3QvaW5maW5pdGUtbGlzdC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogRGlyZWN0aXZlIHdpbGwgbm90aWZ5IHdoZW4gbGlzdCBzY3JvbGxlZCB1cCBvciBkb3duIHRvIGEgZ2l2ZW4gdGhyZXNob2xkLlxuICogQnkgZGVmYXVsdCBpdCBsaXN0ZW4gdG8gc2Nyb2xsIG9mIGxpc3Qgb24gd2hpY2ggYXBwbGllZCwgYnV0IGFsc28gY2FuIGJlIHNldCB0byBsaXN0ZW4gdG8gd2luZG93IHNjcm9sbC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNjcm9sbCBtb2RlcywgaW5maW5pdGUtbGlzdC9pbmZpbml0ZS1saXN0LXNjcm9sbC1tb2Rlcy5jb21wb25lbnQpXG4gKlxuICogVG8gaW1wcm92ZSBVWCBvZiBpbmZpbml0ZSBsaXN0cywgaXQncyBiZXR0ZXIgdG8ga2VlcCBjdXJyZW50IHBhZ2UgaW4gdXJsLFxuICogc28gdXNlciBhYmxlIHRvIHJldHVybiB0byB0aGUgbGFzdCB2aWV3ZWQgcGFnZSBvciB0byBzaGFyZSBhIGxpbmsgdG8gdGhpcyBwYWdlLlxuICogYG5iTGlzdFBhZ2VUcmFja2VyYCBkaXJlY3RpdmUgd2lsbCBoZWxwIHlvdSB0byBrbm93LCB3aGF0IHBhZ2UgdXNlciBjdXJyZW50bHkgdmlld2luZy5cbiAqIEp1c3QgcHV0IGl0IG9uIGEgbGlzdCwgc2V0IHBhZ2Ugc2l6ZSBhbmQgaXQgd2lsbCBjYWxjdWxhdGUgcGFnZSB0aGF0IGN1cnJlbnRseSBpbiB2aWV3cG9ydC5cbiAqIFlvdSBjYW4gW29wZW4gdGhlIGV4YW1wbGVdKGV4YW1wbGUvaW5maW5pdGUtbGlzdC9pbmZpbml0ZS1uZXdzLWxpc3QuY29tcG9uZW50KVxuICogaW4gYSBuZXcgdGFiIHRvIGNoZWNrIG91dCB0aGlzIGZlYXR1cmUuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShJbmZpbml0ZSBsaXN0IHdpdGggcGFnZXIsIGluZmluaXRlLWxpc3QvaW5maW5pdGUtbmV3cy1saXN0LmNvbXBvbmVudClcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEluZmluaXRlIGxpc3Qgd2l0aCBwbGFjZWhvbGRlcnMgYXQgdGhlIHRvcCwgaW5maW5pdGUtbGlzdC9pbmZpbml0ZS1saXN0LXBsYWNlaG9sZGVycy5jb21wb25lbnQpXG4gKlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYkluZmluaXRlTGlzdERpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmO1xuICAgIHByaXZhdGUgc2Nyb2xsU2VydmljZTtcbiAgICBwcml2YXRlIGRpbWVuc2lvbnNTZXJ2aWNlO1xuICAgIHByaXZhdGUgZGVzdHJveSQ7XG4gICAgcHJpdmF0ZSBsYXN0U2Nyb2xsUG9zaXRpb247XG4gICAgd2luZG93U2Nyb2xsOiBib29sZWFuO1xuICAgIHByaXZhdGUgZ2V0IGVsZW1lbnRTY3JvbGwoKTtcbiAgICAvKipcbiAgICAgKiBUaHJlc2hvbGQgYWZ0ZXIgd2hpY2ggZXZlbnQgbG9hZCBtb3JlIGV2ZW50IHdpbGwgYmUgZW1pdGVkLlxuICAgICAqIEluIHBpeGVscy5cbiAgICAgKi9cbiAgICB0aHJlc2hvbGQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0IGNvbXBvbmVudCBvYnNlcnZlcyBsaXN0IHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCBjb21wb25lbnQgd2lsbCBvYnNlcnZlIHBvc2l0aW9uIG9mIHBhZ2Ugc2Nyb2xsIGluc3RlYWQuXG4gICAgICovXG4gICAgc2V0IGxpc3RlbldpbmRvd1Njcm9sbCh2YWx1ZTogYW55KTtcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbGlzdGVuV2luZG93U2Nyb2xsOiBOYkJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIGRpc3RhbmNlIGJldHdlZW4gbGlzdCBib3R0b20gYW5kIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGlzIGxlc3MgdGhhbiB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgYm90dG9tVGhyZXNob2xkOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIGRpc3RhbmNlIGJldHdlZW4gbGlzdCB0b3AgYW5kIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGlzIGxlc3MgdGhhbiB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgdG9wVGhyZXNob2xkOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBvbkVsZW1lbnRTY3JvbGwoKTogdm9pZDtcbiAgICBsaXN0SXRlbXM6IFF1ZXJ5TGlzdDxOYkxpc3RJdGVtQ29tcG9uZW50PjtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBzY3JvbGxTZXJ2aWNlOiBOYkxheW91dFNjcm9sbFNlcnZpY2UsIGRpbWVuc2lvbnNTZXJ2aWNlOiBOYkxheW91dFJ1bGVyU2VydmljZSk7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBjaGVja1Bvc2l0aW9uKHsgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AsIGNsaWVudEhlaWdodCB9OiBOYlNjcm9sbGFibGVDb250YWluZXJEaW1lbnRpb25zKTogdm9pZDtcbiAgICBwcml2YXRlIGdldENvbnRhaW5lckRpbWVuc2lvbnM7XG4gICAgcHJpdmF0ZSBpblN5bmNXaXRoRG9tO1xufVxuIl19