/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { AfterViewInit, ElementRef, OnDestroy, Renderer2, ViewContainerRef } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { NbBooleanInput } from '../helpers';
import { NbThemeService } from '../../services/theme.service';
import { NbSpinnerService } from '../../services/spinner.service';
import { NbLayoutDirectionService } from '../../services/direction.service';
import { NbRestoreScrollTopHelper } from './restore-scroll-top.service';
import { NbScrollPosition, NbLayoutScrollService } from '../../services/scroll.service';
import { NbLayoutDimensions, NbLayoutRulerService } from '../../services/ruler.service';
import { NbOverlayContainerAdapter } from '../cdk/adapter/overlay-container-adapter';
/**
 * Layout container component.
 * When using with Nebular Theme System it is required that all child components should be placed inside.
 *
 * Basic example of two column layout with header:
 *
 * @stacked-example(Showcase, layout/layout-showcase.component)
 *
 * Can contain the following components inside:
 *
 * ```html
 * <nb-layout>
 *  <nb-layout-header></nb-layout-header>
 *  <nb-layout-footer></nb-layout-footer>
 *  <nb-layout-column></nb-layout-column>
 *  <nb-sidebar></nb-sidebar>
 * </nb-layout>
 * ```
 * ### Installation
 *
 * Import `NbLayoutModule` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbLayoutModule,
 *   ],
 * })
 * export class AppModule { }
 * ```
 * ### Usage
 * By default the layout fills up the whole view-port.
 * The window scrollbars are disabled on the body and moved inside of the nb-layout, so that the scrollbars
 * won't mess with the fixed nb-header.
 *
 * The child components are projected into a flexible layout structure allowing to adjust the layout behavior
 * based on the settings provided.
 *
 * The layout content (columns) becomes centered when the window width is more than
 * the value specified in the theme variable `layout-content-width`.
 *
 * The layout also contains the area on the very top (the first child of the nb-layout), which could be used
 * to dynamically append some components like modals or spinners/loaders
 * so that they are located on top of the elements hierarchy.
 * More details are under the `ThemeService` section.
 *
 * The layout component is also responsible for changing application themes.
 * It listens to the `themeChange` event and change a theme CSS class appended to body.
 * Based on the class appended, specific CSS-theme is applied to the application.
 * More details of the Theme System could be found here [Enabling Theme System](#/docs/concepts/theme-system)
 *
 * A simple layout with footer:
 *
 * @stacked-example(Layout With Footer, layout/layout-w-footer.component)
 *
 * It is possible to ask the layout to center the columns (notice: we added a `center` attribute
 * to the layout:
 *
 * ```html
 * <nb-layout center>
 *   <nb-layout-header>Awesome Company</nb-layout-header>
 *
 *   <nb-layout-column>
 *     Hello World!
 *   </nb-layout-column>
 *
 *   <nb-layout-footer>Contact us</nb-layout-footer>
 * </nb-layout>
 * ```
 *
 * @styles
 *
 * layout-background-color:
 * layout-text-color:
 * layout-text-font-family:
 * layout-text-font-size:
 * layout-text-font-weight:
 * layout-text-line-height:
 * layout-min-height:
 * layout-content-width:
 * layout-window-mode-min-width:
 * layout-window-mode-max-width:
 * layout-window-mode-background-color:
 * layout-window-mode-padding-top:
 * layout-window-shadow:
 * layout-padding:
 * layout-medium-padding:
 * layout-small-padding:
 * layout-scrollbar-background-color:
 * layout-scrollbar-color:
 * layout-scrollbar-width:
 */
import * as ɵngcc0 from '@angular/core';
export declare class NbLayoutComponent implements AfterViewInit, OnDestroy {
    protected themeService: NbThemeService;
    protected spinnerService: NbSpinnerService;
    protected elementRef: ElementRef;
    protected renderer: Renderer2;
    protected window: any;
    protected document: any;
    protected platformId: Object;
    protected layoutDirectionService: NbLayoutDirectionService;
    protected scrollService: NbLayoutScrollService;
    protected rulerService: NbLayoutRulerService;
    protected scrollTop: NbRestoreScrollTopHelper;
    protected overlayContainer: NbOverlayContainerAdapter;
    protected scrollBlockClass: string;
    protected isScrollBlocked: boolean;
    protected scrollableContainerOverflowOldValue: string;
    protected layoutPaddingOldValue: {
        left: string;
        right: string;
    };
    centerValue: boolean;
    restoreScrollTopValue: boolean;
    windowModeValue: boolean;
    withScrollValue: boolean;
    withSubheader: boolean;
    /**
     * Defines whether the layout columns will be centered after some width
     * @param {boolean} val
     */
    set center(val: boolean);
    static ngAcceptInputType_center: NbBooleanInput;
    /**
     * Defines whether the layout enters a 'window' mode, when the layout content (including sidebars and fixed header)
     * becomes centered by width with a margin from the top of the screen, like a floating window.
     * Automatically enables `withScroll` mode, as in the window mode scroll must be inside the layout and cannot be on
     * window. (TODO: check this)
     * @param {boolean} val
     */
    set windowMode(val: boolean);
    static ngAcceptInputType_windowMode: NbBooleanInput;
    /**
     * Defines whether to move the scrollbars to layout or leave it at the body level.
     * Automatically set to true when `windowMode` is enabled.
     * @param {boolean} val
     */
    set withScroll(val: boolean);
    static ngAcceptInputType_withScroll: NbBooleanInput;
    /**
     * Restores scroll to the top of the page after navigation
     * @param {boolean} val
     */
    set restoreScrollTop(val: boolean);
    static ngAcceptInputType_restoreScrollTop: NbBooleanInput;
    veryTopRef: ViewContainerRef;
    scrollableContainerRef: ElementRef<HTMLElement>;
    layoutContainerRef: ElementRef<HTMLElement>;
    protected afterViewInit$: BehaviorSubject<any>;
    private destroy$;
    constructor(themeService: NbThemeService, spinnerService: NbSpinnerService, elementRef: ElementRef, renderer: Renderer2, window: any, document: any, platformId: Object, layoutDirectionService: NbLayoutDirectionService, scrollService: NbLayoutScrollService, rulerService: NbLayoutRulerService, scrollTop: NbRestoreScrollTopHelper, overlayContainer: NbOverlayContainerAdapter);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    onScroll($event: any): void;
    onResize(event: any): void;
    /**
     * Returns scroll and client height/width
     *
     * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element
     * or from the `.scrollable-container`
     * @returns {NbLayoutDimensions}
     */
    getDimensions(): NbLayoutDimensions;
    /**
     * Returns scroll position of current scroll container.
     *
     * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,
     * otherwise - of the scrollable element of the window (which may be different depending of a browser)
     *
     * @returns {NbScrollPosition}
     */
    getScrollPosition(): NbScrollPosition;
    protected registerAsOverlayContainer(): void;
    protected unregisterAsOverlayContainer(): void;
    private scroll;
    protected blockScroll(): void;
    private enableScroll;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbLayoutComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbLayoutComponent, "nb-layout", never, { "center": "center"; "windowMode": "windowMode"; "withScroll": "withScroll"; "restoreScrollTop": "restoreScrollTop"; }, {}, never, ["nb-layout-header:not([subheader])", "nb-sidebar", "nb-layout-header[subheader]", "nb-layout-column", "nb-layout-footer"]>;
}
/**
 * A container component which determines a content position inside of the layout.
 * The layout could contain unlimited columns (not including the sidebars).
 *
 * By default the columns are ordered from the left to the right,
 * but it's also possible to overwrite this behavior by setting a `left` attribute to the column,
 * moving it to the very first position:
 *
 * @stacked-example(Column Left, layout/layout-column-left.component)
 */
export declare class NbLayoutColumnComponent {
    leftValue: boolean;
    startValue: boolean;
    /**
     * Move the column to the very left position in the layout.
     * @param {boolean} val
     */
    set left(val: boolean);
    static ngAcceptInputType_left: NbBooleanInput;
    /**
     * Make column first in the layout.
     * @param {boolean} val
     */
    set start(val: boolean);
    static ngAcceptInputType_start: NbBooleanInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbLayoutColumnComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbLayoutColumnComponent, "nb-layout-column", never, { "left": "left"; "start": "start"; }, {}, never, ["*"]>;
}
/**
 * Page header component.
 * Located on top of the page above the layout columns and sidebars.
 * Could be made `fixed` by setting the corresponding property. In the fixed mode the header becomes
 * sticky to the top of the nb-layout (to of the page). Here's an example:
 *
 * @stacked-example(Fixed Header, layout/layout-fixed-header.component)
 *
 * In a pair with sidebar it is possible to setup a configuration when header is placed on a side of the sidebar
 * and not on top of it. To achieve this simply put a `subheader` property to the header like this:
 * ```html
 * <nb-layout-header subheader></nb-layout-header>
 * ```
 * @stacked-example(Subheader, layout/layout-sidebar-subheader.component)
 * Note that in such configuration sidebar shadow is removed and header cannot be make `fixed`.
 *
 * Same way you can put both `fixed` and `clipped` headers adding creating a sub-header for your app:
 *
 * @stacked-example(Subheader, layout/layout-subheader.component)
 *
 * @styles
 *
 * header-background-color:
 * header-text-color:
 * header-text-font-family:
 * header-text-font-size:
 * header-text-font-weight:
 * header-text-line-height:
 * header-height:
 * header-padding:
 * header-shadow:
 */
export declare class NbLayoutHeaderComponent {
    private layout;
    fixedValue: boolean;
    subheaderValue: boolean;
    constructor(layout: NbLayoutComponent);
    /**
     * Makes the header sticky to the top of the nb-layout.
     * @param {boolean} val
     */
    set fixed(val: boolean);
    static ngAcceptInputType_fixed: NbBooleanInput;
    /**
     * Places header on a side of the sidebar, and not above.
     * Disables fixed mode for this header and remove a shadow from the sidebar.
     * @param {boolean} val
     */
    set subheader(val: boolean);
    static ngAcceptInputType_subheader: NbBooleanInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbLayoutHeaderComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbLayoutHeaderComponent, "nb-layout-header", never, { "fixed": "fixed"; "subheader": "subheader"; }, {}, never, ["*"]>;
}
/**
 * Page footer.
 * Located under the nb-layout content (specifically, under the columns).
 * Could be made `fixed`, becoming sticky to the bottom of the view port (window).
 *
 * @styles
 *
 * footer-background-color:
 * footer-text-color:
 * footer-text-font-family:
 * footer-text-font-size:
 * footer-text-font-weight:
 * footer-text-line-height:
 * footer-text-highlight-color:
 * footer-height:
 * footer-padding:
 * footer-divider-color:
 * footer-divider-style:
 * footer-divider-width:
 * footer-shadow:
 */
export declare class NbLayoutFooterComponent {
    fixedValue: boolean;
    /**
     * Makes the footer sticky to the bottom of the window.
     * @param {boolean} val
     */
    set fixed(val: boolean);
    static ngAcceptInputType_fixed: NbBooleanInput;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbLayoutFooterComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbLayoutFooterComponent, "nb-layout-footer", never, { "fixed": "fixed"; }, {}, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF5b3V0LmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJsYXlvdXQuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUZBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1EQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIFJlbmRlcmVyMiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOYkJvb2xlYW5JbnB1dCB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgTmJUaGVtZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy90aGVtZS5zZXJ2aWNlJztcbmltcG9ydCB7IE5iU3Bpbm5lclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9zcGlubmVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZGlyZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmJSZXN0b3JlU2Nyb2xsVG9wSGVscGVyIH0gZnJvbSAnLi9yZXN0b3JlLXNjcm9sbC10b3Auc2VydmljZSc7XG5pbXBvcnQgeyBOYlNjcm9sbFBvc2l0aW9uLCBOYkxheW91dFNjcm9sbFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9zY3JvbGwuc2VydmljZSc7XG5pbXBvcnQgeyBOYkxheW91dERpbWVuc2lvbnMsIE5iTGF5b3V0UnVsZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcnVsZXIuc2VydmljZSc7XG5pbXBvcnQgeyBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyIH0gZnJvbSAnLi4vY2RrL2FkYXB0ZXIvb3ZlcmxheS1jb250YWluZXItYWRhcHRlcic7XG4vKipcbiAqIExheW91dCBjb250YWluZXIgY29tcG9uZW50LlxuICogV2hlbiB1c2luZyB3aXRoIE5lYnVsYXIgVGhlbWUgU3lzdGVtIGl0IGlzIHJlcXVpcmVkIHRoYXQgYWxsIGNoaWxkIGNvbXBvbmVudHMgc2hvdWxkIGJlIHBsYWNlZCBpbnNpZGUuXG4gKlxuICogQmFzaWMgZXhhbXBsZSBvZiB0d28gY29sdW1uIGxheW91dCB3aXRoIGhlYWRlcjpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBsYXlvdXQvbGF5b3V0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBDYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMgaW5zaWRlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1sYXlvdXQ+XG4gKiAgPG5iLWxheW91dC1oZWFkZXI+PC9uYi1sYXlvdXQtaGVhZGVyPlxuICogIDxuYi1sYXlvdXQtZm9vdGVyPjwvbmItbGF5b3V0LWZvb3Rlcj5cbiAqICA8bmItbGF5b3V0LWNvbHVtbj48L25iLWxheW91dC1jb2x1bW4+XG4gKiAgPG5iLXNpZGViYXI+PC9uYi1zaWRlYmFyPlxuICogPC9uYi1sYXlvdXQ+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iTGF5b3V0TW9kdWxlYCB0byB5b3VyIGFwcCBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iTGF5b3V0TW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICogQnkgZGVmYXVsdCB0aGUgbGF5b3V0IGZpbGxzIHVwIHRoZSB3aG9sZSB2aWV3LXBvcnQuXG4gKiBUaGUgd2luZG93IHNjcm9sbGJhcnMgYXJlIGRpc2FibGVkIG9uIHRoZSBib2R5IGFuZCBtb3ZlZCBpbnNpZGUgb2YgdGhlIG5iLWxheW91dCwgc28gdGhhdCB0aGUgc2Nyb2xsYmFyc1xuICogd29uJ3QgbWVzcyB3aXRoIHRoZSBmaXhlZCBuYi1oZWFkZXIuXG4gKlxuICogVGhlIGNoaWxkIGNvbXBvbmVudHMgYXJlIHByb2plY3RlZCBpbnRvIGEgZmxleGlibGUgbGF5b3V0IHN0cnVjdHVyZSBhbGxvd2luZyB0byBhZGp1c3QgdGhlIGxheW91dCBiZWhhdmlvclxuICogYmFzZWQgb24gdGhlIHNldHRpbmdzIHByb3ZpZGVkLlxuICpcbiAqIFRoZSBsYXlvdXQgY29udGVudCAoY29sdW1ucykgYmVjb21lcyBjZW50ZXJlZCB3aGVuIHRoZSB3aW5kb3cgd2lkdGggaXMgbW9yZSB0aGFuXG4gKiB0aGUgdmFsdWUgc3BlY2lmaWVkIGluIHRoZSB0aGVtZSB2YXJpYWJsZSBgbGF5b3V0LWNvbnRlbnQtd2lkdGhgLlxuICpcbiAqIFRoZSBsYXlvdXQgYWxzbyBjb250YWlucyB0aGUgYXJlYSBvbiB0aGUgdmVyeSB0b3AgKHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgbmItbGF5b3V0KSwgd2hpY2ggY291bGQgYmUgdXNlZFxuICogdG8gZHluYW1pY2FsbHkgYXBwZW5kIHNvbWUgY29tcG9uZW50cyBsaWtlIG1vZGFscyBvciBzcGlubmVycy9sb2FkZXJzXG4gKiBzbyB0aGF0IHRoZXkgYXJlIGxvY2F0ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50cyBoaWVyYXJjaHkuXG4gKiBNb3JlIGRldGFpbHMgYXJlIHVuZGVyIHRoZSBgVGhlbWVTZXJ2aWNlYCBzZWN0aW9uLlxuICpcbiAqIFRoZSBsYXlvdXQgY29tcG9uZW50IGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGNoYW5naW5nIGFwcGxpY2F0aW9uIHRoZW1lcy5cbiAqIEl0IGxpc3RlbnMgdG8gdGhlIGB0aGVtZUNoYW5nZWAgZXZlbnQgYW5kIGNoYW5nZSBhIHRoZW1lIENTUyBjbGFzcyBhcHBlbmRlZCB0byBib2R5LlxuICogQmFzZWQgb24gdGhlIGNsYXNzIGFwcGVuZGVkLCBzcGVjaWZpYyBDU1MtdGhlbWUgaXMgYXBwbGllZCB0byB0aGUgYXBwbGljYXRpb24uXG4gKiBNb3JlIGRldGFpbHMgb2YgdGhlIFRoZW1lIFN5c3RlbSBjb3VsZCBiZSBmb3VuZCBoZXJlIFtFbmFibGluZyBUaGVtZSBTeXN0ZW1dKCMvZG9jcy9jb25jZXB0cy90aGVtZS1zeXN0ZW0pXG4gKlxuICogQSBzaW1wbGUgbGF5b3V0IHdpdGggZm9vdGVyOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTGF5b3V0IFdpdGggRm9vdGVyLCBsYXlvdXQvbGF5b3V0LXctZm9vdGVyLmNvbXBvbmVudClcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhc2sgdGhlIGxheW91dCB0byBjZW50ZXIgdGhlIGNvbHVtbnMgKG5vdGljZTogd2UgYWRkZWQgYSBgY2VudGVyYCBhdHRyaWJ1dGVcbiAqIHRvIHRoZSBsYXlvdXQ6XG4gKlxuICogYGBgaHRtbFxuICogPG5iLWxheW91dCBjZW50ZXI+XG4gKiAgIDxuYi1sYXlvdXQtaGVhZGVyPkF3ZXNvbWUgQ29tcGFueTwvbmItbGF5b3V0LWhlYWRlcj5cbiAqXG4gKiAgIDxuYi1sYXlvdXQtY29sdW1uPlxuICogICAgIEhlbGxvIFdvcmxkIVxuICogICA8L25iLWxheW91dC1jb2x1bW4+XG4gKlxuICogICA8bmItbGF5b3V0LWZvb3Rlcj5Db250YWN0IHVzPC9uYi1sYXlvdXQtZm9vdGVyPlxuICogPC9uYi1sYXlvdXQ+XG4gKiBgYGBcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogbGF5b3V0LWJhY2tncm91bmQtY29sb3I6XG4gKiBsYXlvdXQtdGV4dC1jb2xvcjpcbiAqIGxheW91dC10ZXh0LWZvbnQtZmFtaWx5OlxuICogbGF5b3V0LXRleHQtZm9udC1zaXplOlxuICogbGF5b3V0LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBsYXlvdXQtdGV4dC1saW5lLWhlaWdodDpcbiAqIGxheW91dC1taW4taGVpZ2h0OlxuICogbGF5b3V0LWNvbnRlbnQtd2lkdGg6XG4gKiBsYXlvdXQtd2luZG93LW1vZGUtbWluLXdpZHRoOlxuICogbGF5b3V0LXdpbmRvdy1tb2RlLW1heC13aWR0aDpcbiAqIGxheW91dC13aW5kb3ctbW9kZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogbGF5b3V0LXdpbmRvdy1tb2RlLXBhZGRpbmctdG9wOlxuICogbGF5b3V0LXdpbmRvdy1zaGFkb3c6XG4gKiBsYXlvdXQtcGFkZGluZzpcbiAqIGxheW91dC1tZWRpdW0tcGFkZGluZzpcbiAqIGxheW91dC1zbWFsbC1wYWRkaW5nOlxuICogbGF5b3V0LXNjcm9sbGJhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogbGF5b3V0LXNjcm9sbGJhci1jb2xvcjpcbiAqIGxheW91dC1zY3JvbGxiYXItd2lkdGg6XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iTGF5b3V0Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICBwcm90ZWN0ZWQgdGhlbWVTZXJ2aWNlOiBOYlRoZW1lU2VydmljZTtcbiAgICBwcm90ZWN0ZWQgc3Bpbm5lclNlcnZpY2U6IE5iU3Bpbm5lclNlcnZpY2U7XG4gICAgcHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG4gICAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjI7XG4gICAgcHJvdGVjdGVkIHdpbmRvdzogYW55O1xuICAgIHByb3RlY3RlZCBkb2N1bWVudDogYW55O1xuICAgIHByb3RlY3RlZCBwbGF0Zm9ybUlkOiBPYmplY3Q7XG4gICAgcHJvdGVjdGVkIGxheW91dERpcmVjdGlvblNlcnZpY2U6IE5iTGF5b3V0RGlyZWN0aW9uU2VydmljZTtcbiAgICBwcm90ZWN0ZWQgc2Nyb2xsU2VydmljZTogTmJMYXlvdXRTY3JvbGxTZXJ2aWNlO1xuICAgIHByb3RlY3RlZCBydWxlclNlcnZpY2U6IE5iTGF5b3V0UnVsZXJTZXJ2aWNlO1xuICAgIHByb3RlY3RlZCBzY3JvbGxUb3A6IE5iUmVzdG9yZVNjcm9sbFRvcEhlbHBlcjtcbiAgICBwcm90ZWN0ZWQgb3ZlcmxheUNvbnRhaW5lcjogTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlcjtcbiAgICBwcm90ZWN0ZWQgc2Nyb2xsQmxvY2tDbGFzczogc3RyaW5nO1xuICAgIHByb3RlY3RlZCBpc1Njcm9sbEJsb2NrZWQ6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIHNjcm9sbGFibGVDb250YWluZXJPdmVyZmxvd09sZFZhbHVlOiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIGxheW91dFBhZGRpbmdPbGRWYWx1ZToge1xuICAgICAgICBsZWZ0OiBzdHJpbmc7XG4gICAgICAgIHJpZ2h0OiBzdHJpbmc7XG4gICAgfTtcbiAgICBjZW50ZXJWYWx1ZTogYm9vbGVhbjtcbiAgICByZXN0b3JlU2Nyb2xsVG9wVmFsdWU6IGJvb2xlYW47XG4gICAgd2luZG93TW9kZVZhbHVlOiBib29sZWFuO1xuICAgIHdpdGhTY3JvbGxWYWx1ZTogYm9vbGVhbjtcbiAgICB3aXRoU3ViaGVhZGVyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hldGhlciB0aGUgbGF5b3V0IGNvbHVtbnMgd2lsbCBiZSBjZW50ZXJlZCBhZnRlciBzb21lIHdpZHRoXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgY2VudGVyKHZhbDogYm9vbGVhbik7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2NlbnRlcjogTmJCb29sZWFuSW5wdXQ7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBsYXlvdXQgZW50ZXJzIGEgJ3dpbmRvdycgbW9kZSwgd2hlbiB0aGUgbGF5b3V0IGNvbnRlbnQgKGluY2x1ZGluZyBzaWRlYmFycyBhbmQgZml4ZWQgaGVhZGVyKVxuICAgICAqIGJlY29tZXMgY2VudGVyZWQgYnkgd2lkdGggd2l0aCBhIG1hcmdpbiBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcmVlbiwgbGlrZSBhIGZsb2F0aW5nIHdpbmRvdy5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGVuYWJsZXMgYHdpdGhTY3JvbGxgIG1vZGUsIGFzIGluIHRoZSB3aW5kb3cgbW9kZSBzY3JvbGwgbXVzdCBiZSBpbnNpZGUgdGhlIGxheW91dCBhbmQgY2Fubm90IGJlIG9uXG4gICAgICogd2luZG93LiAoVE9ETzogY2hlY2sgdGhpcylcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCB3aW5kb3dNb2RlKHZhbDogYm9vbGVhbik7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3dpbmRvd01vZGU6IE5iQm9vbGVhbklucHV0O1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hldGhlciB0byBtb3ZlIHRoZSBzY3JvbGxiYXJzIHRvIGxheW91dCBvciBsZWF2ZSBpdCBhdCB0aGUgYm9keSBsZXZlbC5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IHNldCB0byB0cnVlIHdoZW4gYHdpbmRvd01vZGVgIGlzIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgd2l0aFNjcm9sbCh2YWw6IGJvb2xlYW4pO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV93aXRoU2Nyb2xsOiBOYkJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSBhZnRlciBuYXZpZ2F0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgcmVzdG9yZVNjcm9sbFRvcCh2YWw6IGJvb2xlYW4pO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9yZXN0b3JlU2Nyb2xsVG9wOiBOYkJvb2xlYW5JbnB1dDtcbiAgICB2ZXJ5VG9wUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuICAgIHNjcm9sbGFibGVDb250YWluZXJSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuICAgIGxheW91dENvbnRhaW5lclJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG4gICAgcHJvdGVjdGVkIGFmdGVyVmlld0luaXQkOiBCZWhhdmlvclN1YmplY3Q8YW55PjtcbiAgICBwcml2YXRlIGRlc3Ryb3kkO1xuICAgIGNvbnN0cnVjdG9yKHRoZW1lU2VydmljZTogTmJUaGVtZVNlcnZpY2UsIHNwaW5uZXJTZXJ2aWNlOiBOYlNwaW5uZXJTZXJ2aWNlLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZW5kZXJlcjogUmVuZGVyZXIyLCB3aW5kb3c6IGFueSwgZG9jdW1lbnQ6IGFueSwgcGxhdGZvcm1JZDogT2JqZWN0LCBsYXlvdXREaXJlY3Rpb25TZXJ2aWNlOiBOYkxheW91dERpcmVjdGlvblNlcnZpY2UsIHNjcm9sbFNlcnZpY2U6IE5iTGF5b3V0U2Nyb2xsU2VydmljZSwgcnVsZXJTZXJ2aWNlOiBOYkxheW91dFJ1bGVyU2VydmljZSwgc2Nyb2xsVG9wOiBOYlJlc3RvcmVTY3JvbGxUb3BIZWxwZXIsIG92ZXJsYXlDb250YWluZXI6IE5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXIpO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgb25TY3JvbGwoJGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIG9uUmVzaXplKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2Nyb2xsIGFuZCBjbGllbnQgaGVpZ2h0L3dpZHRoXG4gICAgICpcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgc2Nyb2xsIG1vZGUgKGB3aXRoU2Nyb2xsPXRydWVgKSByZXR1cm5zIHNpemVzIGZyb20gdGhlIGJvZHkgZWxlbWVudFxuICAgICAqIG9yIGZyb20gdGhlIGAuc2Nyb2xsYWJsZS1jb250YWluZXJgXG4gICAgICogQHJldHVybnMge05iTGF5b3V0RGltZW5zaW9uc31cbiAgICAgKi9cbiAgICBnZXREaW1lbnNpb25zKCk6IE5iTGF5b3V0RGltZW5zaW9ucztcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNjcm9sbCBwb3NpdGlvbiBvZiBjdXJyZW50IHNjcm9sbCBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBJZiBgd2l0aFNjcm9sbGAgPSB0cnVlLCByZXR1cm5zIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgYC5zY3JvbGxhYmxlLWNvbnRhaW5lcmAgZWxlbWVudCxcbiAgICAgKiBvdGhlcndpc2UgLSBvZiB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IG9mIHRoZSB3aW5kb3cgKHdoaWNoIG1heSBiZSBkaWZmZXJlbnQgZGVwZW5kaW5nIG9mIGEgYnJvd3NlcilcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOYlNjcm9sbFBvc2l0aW9ufVxuICAgICAqL1xuICAgIGdldFNjcm9sbFBvc2l0aW9uKCk6IE5iU2Nyb2xsUG9zaXRpb247XG4gICAgcHJvdGVjdGVkIHJlZ2lzdGVyQXNPdmVybGF5Q29udGFpbmVyKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIHVucmVnaXN0ZXJBc092ZXJsYXlDb250YWluZXIoKTogdm9pZDtcbiAgICBwcml2YXRlIHNjcm9sbDtcbiAgICBwcm90ZWN0ZWQgYmxvY2tTY3JvbGwoKTogdm9pZDtcbiAgICBwcml2YXRlIGVuYWJsZVNjcm9sbDtcbn1cbi8qKlxuICogQSBjb250YWluZXIgY29tcG9uZW50IHdoaWNoIGRldGVybWluZXMgYSBjb250ZW50IHBvc2l0aW9uIGluc2lkZSBvZiB0aGUgbGF5b3V0LlxuICogVGhlIGxheW91dCBjb3VsZCBjb250YWluIHVubGltaXRlZCBjb2x1bW5zIChub3QgaW5jbHVkaW5nIHRoZSBzaWRlYmFycykuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgY29sdW1ucyBhcmUgb3JkZXJlZCBmcm9tIHRoZSBsZWZ0IHRvIHRoZSByaWdodCxcbiAqIGJ1dCBpdCdzIGFsc28gcG9zc2libGUgdG8gb3ZlcndyaXRlIHRoaXMgYmVoYXZpb3IgYnkgc2V0dGluZyBhIGBsZWZ0YCBhdHRyaWJ1dGUgdG8gdGhlIGNvbHVtbixcbiAqIG1vdmluZyBpdCB0byB0aGUgdmVyeSBmaXJzdCBwb3NpdGlvbjpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbHVtbiBMZWZ0LCBsYXlvdXQvbGF5b3V0LWNvbHVtbi1sZWZ0LmNvbXBvbmVudClcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJMYXlvdXRDb2x1bW5Db21wb25lbnQge1xuICAgIGxlZnRWYWx1ZTogYm9vbGVhbjtcbiAgICBzdGFydFZhbHVlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIGNvbHVtbiB0byB0aGUgdmVyeSBsZWZ0IHBvc2l0aW9uIGluIHRoZSBsYXlvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgbGVmdCh2YWw6IGJvb2xlYW4pO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9sZWZ0OiBOYkJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBNYWtlIGNvbHVtbiBmaXJzdCBpbiB0aGUgbGF5b3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IHN0YXJ0KHZhbDogYm9vbGVhbik7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N0YXJ0OiBOYkJvb2xlYW5JbnB1dDtcbn1cbi8qKlxuICogUGFnZSBoZWFkZXIgY29tcG9uZW50LlxuICogTG9jYXRlZCBvbiB0b3Agb2YgdGhlIHBhZ2UgYWJvdmUgdGhlIGxheW91dCBjb2x1bW5zIGFuZCBzaWRlYmFycy5cbiAqIENvdWxkIGJlIG1hZGUgYGZpeGVkYCBieSBzZXR0aW5nIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5LiBJbiB0aGUgZml4ZWQgbW9kZSB0aGUgaGVhZGVyIGJlY29tZXNcbiAqIHN0aWNreSB0byB0aGUgdG9wIG9mIHRoZSBuYi1sYXlvdXQgKHRvIG9mIHRoZSBwYWdlKS4gSGVyZSdzIGFuIGV4YW1wbGU6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShGaXhlZCBIZWFkZXIsIGxheW91dC9sYXlvdXQtZml4ZWQtaGVhZGVyLmNvbXBvbmVudClcbiAqXG4gKiBJbiBhIHBhaXIgd2l0aCBzaWRlYmFyIGl0IGlzIHBvc3NpYmxlIHRvIHNldHVwIGEgY29uZmlndXJhdGlvbiB3aGVuIGhlYWRlciBpcyBwbGFjZWQgb24gYSBzaWRlIG9mIHRoZSBzaWRlYmFyXG4gKiBhbmQgbm90IG9uIHRvcCBvZiBpdC4gVG8gYWNoaWV2ZSB0aGlzIHNpbXBseSBwdXQgYSBgc3ViaGVhZGVyYCBwcm9wZXJ0eSB0byB0aGUgaGVhZGVyIGxpa2UgdGhpczpcbiAqIGBgYGh0bWxcbiAqIDxuYi1sYXlvdXQtaGVhZGVyIHN1YmhlYWRlcj48L25iLWxheW91dC1oZWFkZXI+XG4gKiBgYGBcbiAqIEBzdGFja2VkLWV4YW1wbGUoU3ViaGVhZGVyLCBsYXlvdXQvbGF5b3V0LXNpZGViYXItc3ViaGVhZGVyLmNvbXBvbmVudClcbiAqIE5vdGUgdGhhdCBpbiBzdWNoIGNvbmZpZ3VyYXRpb24gc2lkZWJhciBzaGFkb3cgaXMgcmVtb3ZlZCBhbmQgaGVhZGVyIGNhbm5vdCBiZSBtYWtlIGBmaXhlZGAuXG4gKlxuICogU2FtZSB3YXkgeW91IGNhbiBwdXQgYm90aCBgZml4ZWRgIGFuZCBgY2xpcHBlZGAgaGVhZGVycyBhZGRpbmcgY3JlYXRpbmcgYSBzdWItaGVhZGVyIGZvciB5b3VyIGFwcDpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFN1YmhlYWRlciwgbGF5b3V0L2xheW91dC1zdWJoZWFkZXIuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBoZWFkZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGhlYWRlci10ZXh0LWNvbG9yOlxuICogaGVhZGVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBoZWFkZXItdGV4dC1mb250LXNpemU6XG4gKiBoZWFkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGhlYWRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogaGVhZGVyLWhlaWdodDpcbiAqIGhlYWRlci1wYWRkaW5nOlxuICogaGVhZGVyLXNoYWRvdzpcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJMYXlvdXRIZWFkZXJDb21wb25lbnQge1xuICAgIHByaXZhdGUgbGF5b3V0O1xuICAgIGZpeGVkVmFsdWU6IGJvb2xlYW47XG4gICAgc3ViaGVhZGVyVmFsdWU6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IobGF5b3V0OiBOYkxheW91dENvbXBvbmVudCk7XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIGhlYWRlciBzdGlja3kgdG8gdGhlIHRvcCBvZiB0aGUgbmItbGF5b3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IGZpeGVkKHZhbDogYm9vbGVhbik7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2ZpeGVkOiBOYkJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBQbGFjZXMgaGVhZGVyIG9uIGEgc2lkZSBvZiB0aGUgc2lkZWJhciwgYW5kIG5vdCBhYm92ZS5cbiAgICAgKiBEaXNhYmxlcyBmaXhlZCBtb2RlIGZvciB0aGlzIGhlYWRlciBhbmQgcmVtb3ZlIGEgc2hhZG93IGZyb20gdGhlIHNpZGViYXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgc3ViaGVhZGVyKHZhbDogYm9vbGVhbik7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1YmhlYWRlcjogTmJCb29sZWFuSW5wdXQ7XG59XG4vKipcbiAqIFBhZ2UgZm9vdGVyLlxuICogTG9jYXRlZCB1bmRlciB0aGUgbmItbGF5b3V0IGNvbnRlbnQgKHNwZWNpZmljYWxseSwgdW5kZXIgdGhlIGNvbHVtbnMpLlxuICogQ291bGQgYmUgbWFkZSBgZml4ZWRgLCBiZWNvbWluZyBzdGlja3kgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdmlldyBwb3J0ICh3aW5kb3cpLlxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBmb290ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGZvb3Rlci10ZXh0LWNvbG9yOlxuICogZm9vdGVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBmb290ZXItdGV4dC1mb250LXNpemU6XG4gKiBmb290ZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGZvb3Rlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogZm9vdGVyLXRleHQtaGlnaGxpZ2h0LWNvbG9yOlxuICogZm9vdGVyLWhlaWdodDpcbiAqIGZvb3Rlci1wYWRkaW5nOlxuICogZm9vdGVyLWRpdmlkZXItY29sb3I6XG4gKiBmb290ZXItZGl2aWRlci1zdHlsZTpcbiAqIGZvb3Rlci1kaXZpZGVyLXdpZHRoOlxuICogZm9vdGVyLXNoYWRvdzpcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJMYXlvdXRGb290ZXJDb21wb25lbnQge1xuICAgIGZpeGVkVmFsdWU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIGZvb3RlciBzdGlja3kgdG8gdGhlIGJvdHRvbSBvZiB0aGUgd2luZG93LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IGZpeGVkKHZhbDogYm9vbGVhbik7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2ZpeGVkOiBOYkJvb2xlYW5JbnB1dDtcbn1cbiJdfQ==